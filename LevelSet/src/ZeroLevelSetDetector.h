//-----------------------------------------------------------------------------------------------------------------------------
#ifndef ZEROLEVELSETDETECTOR_H_
#define ZEROLEVELSETDETECTOR_H_
//-----------------------------------------------------------------------------------------------------------------------------
#include <boost/noncopyable.hpp>
#include <vector>
#include "Typedef.h"
#include <list>
//-----------------------------------------------------------------------------------------------------------------------------

namespace kmd {

        class Cell;
        struct Parameters;
        

        /*!
         *      This class finds out a zero-level set, which corresponds to a front.
         */
        //*********************************************************************************************************************
        class ZeroLevelSetDetector : private boost::noncopyable {
        //*********************************************************************************************************************
                friend class ZeroLevelSetDetectorTester;
        public:
                /*!
                 *      @param[in]      parameters
                 */
                explicit ZeroLevelSetDetector(const Parameters* parameters);
                
                ~ZeroLevelSetDetector();

                /*!
                 *      This method finds out the zero-level set from a given buffer.
                 *      It throw std::runtime_error when failing to detect the zero-level set.
                 *
                 *      @param[in]      buffer          input buffer
                 *      @param[in]      tube            an area to search
                 *      @param[in]      tube_width      witdh of the area
                 */
                void run(const double* buffer, const Tube& tube, int tube_width);

                const Fronts& get_fronts() const {
                        return fronts_;
                }



        private:
                bool includes_zero_level_set(Cell* cell, int offset_x, int offset_y, int cur_x, int cur_y);
                void trace_fronts(Cell* cell, const double* buffer, const Tube& tube, int tube_width);

                double buffer(int i, int j) const {
                        return buffer_[i + width_ * j];
                }

                bool has_already_visited(int i, int j) const {
                        return visit_flags_[i + width_ * j];
                }

                void visit_now(int i, int j) {
                        visit_flags_[i + j * width_] = true;
                }

                void clear_visit_flags() {
                        std::fill(visit_flags_.begin(), visit_flags_.end(), false);
                }

                void delete_fronts();
                void eliminate_current_front();
                void trace_front(Cell* cell);

                static const int        OffsetX_[];
                static const int        OffsetY_[];
                static const int        FlagSizes_[];
                static const int        Flags_[][3];

                int                     width_;
                int                     height_;
                const double*           buffer_;
                std::vector<bool>       visit_flags_;
                int                     first_x_; //!< first position of a front
                int                     first_y_; //!< first position of a front
                Fronts                  fronts_;  //!< container of the fronts generated by the zero-level detection
        };
}
#endif /*ZEROLEVELSETDETECTOR_H_*/
